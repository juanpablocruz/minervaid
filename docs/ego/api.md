# API Reference: Native Messaging & JSON Schemas

This document describes the JSON protocols and schemas used by the Ego Wallet browser extension to communicate with the native `ego` CLI via Native Messaging, as well as the structures for authentication challenges and responses.

---

## 1. Native Messaging Protocol

The browser extension interacts with the local `ego` CLI through a Native Messaging host registered under the name `com.minervaid.ego`. All messages follow a simple JSON envelope and are exchanged over stdin/stdout.

### 1.1 Request Envelope

**Format:**

```json
{
  "cmd": ["<ego-subcommand>", "--flag1", "value1", ...],
  "input": "<optional raw input>"
}
```

* `cmd` (array of strings): The exact arguments to pass to the `ego` binary. For example, `["present", "--reveal", "email"]`.
* `input` (string, optional): If set, it is fed to the CLIâ€™s stdin (e.g., a challenge JSON or other payload).

### 1.2 Response Envelope

**Format:**

```json
{
  "stdout": "<string>",
  "stderr": "<string>",
  "code": <integer>
}
```

* `stdout`: Captures all standard output from the `ego` CLI.
* `stderr`: Captures all error messages from the CLI.
* `code`: Exit code (0 indicates success).

---

## 2. AuthenticationChallenge Schema

An **AuthenticationChallenge** is generated by the Authorization Server via `ego auth-challenge` and sent to the client for signing.

**JSON Structure:**

```jsonc
{
  "type": "AuthenticationChallenge",
  "challenge": "<random-nonce>",
  "domain": "<string>",           // e.g. "api.example.com"
  "issuedAt": "<RFC3339-timestamp>",
  "expiresAt": "<RFC3339-timestamp>"
}
```

* **type**: Always the string `"AuthenticationChallenge"`.
* **challenge**: A cryptographically secure random nonce, used once.
* **domain**: The intended audience or service identifier.
* **issuedAt**: Timestamp when the challenge was created.
* **expiresAt**: Timestamp after which the challenge is invalid.

---

## 3. AuthenticationResponse Schema

After signing the challenge with `ego auth-respond`, the client returns an **AuthenticationResponse** containing the original challenge and a cryptographic proof.

**JSON Structure:**

```jsonc
{
  "challenge": { /* AuthenticationChallenge object */ },
  "proof": {
    "type": "Ed25519Signature2018",
    "created": "<RFC3339-timestamp>",
    "proofPurpose": "authentication",
    "verificationMethod": "<did>#keys-1",
    "jws": "<hex-encoded-signature>"
  }
}
```

* **proof**: A signature over the exact byte sequence of the `challenge` object as received.
* **verificationMethod**: A DID URL pointing to the public key (e.g. `did:key:z...#keys-1`).

**Server Verification Steps:**

1. Resolve the DID from `verificationMethod` to obtain the Ed25519 public key.
2. Serialize the `challenge` JSON to bytes in the exact same ordering received.
3. Base16-decode the `jws` field to obtain the signature bytes.
4. Run `ed25519.Verify(pubKey, serializedChallenge, signatureBytes)`.

---

## 4. Presentation Definition Schema (OIDC4VP)

Web applications may embed a **presentation\_definition** parameter in the OIDC authorize URL. This follows the [W3C Presentation Exchange](https://identity.foundation/presentation-exchange/) spec.

**Example Definition:**

```jsonc
{
  "id": "login_request",
  "input_descriptors": [
    {
      "id": "auth_vc",
      "schema": [ { "uri": "https://www.w3.org/2018/credentials/v1" } ],
      "constraints": {
        "fields": [
          {
            "path": ["$.credentialSubject.email"],
            "filter": { "type": "string", "pattern": ".+@example\\.com$" }
          }
        ]
      }
    }
  ]
}
```

* Must be URL-encoded when included in the `/authorize` request.
* Describes required credential types and claim filters.

---
